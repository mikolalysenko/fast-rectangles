
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - camera - orthographic</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="/gits/three.js/build/three.min.js"></script>

		<script src="/gits/three.js/examples/js/renderers/Projector.js"></script>
		<script src="/gits/three.js/examples/js/renderers/CanvasRenderer.js"></script>

		<script src="/gits/three.js/examples/js/libs/stats.min.js"></script>

		<script>
			var camera, scene, renderer;

			function RectangleMesh(material) {
				var color = new THREE.Color(1, 1, 1);
				material = material || new THREE.MeshBasicMaterial({
					color: color,
					side: THREE.DoubleSide,
					// wireframe: true
				})
				var geometry = new THREE.PlaneGeometry(1, 1, 1, 1);
				THREE.Mesh.call(this, geometry, material);
			}

			RectangleMesh.prototype = Object.create(THREE.Mesh.prototype);

			RectangleMesh.prototype.setRect = function(rect) {
				this.position.x = rect.x + rect.width * .5;
				this.position.y = rect.y + rect.height * .5;
				this.scale.x = rect.width;
				this.scale.y = rect.height;
			}

			var WIDTH = 1024;
			var HEIGHT = 768;

			var DISTANCE = 100;
			var BOX_SIZE = 1;

			var RECTS = 1000;

			init();
			animate();

			function init() {

				// camera = new THREE.OrthographicCamera( WIDTH / - 2, WIDTH / 2, HEIGHT / 2, HEIGHT / - 2, - 500, 1000 );

				camera = new THREE.OrthographicCamera( WIDTH / - 8, WIDTH / 8, HEIGHT / 8, HEIGHT / - 8, - 500, 1000 );
				camera.position.x = 0;
				camera.position.y = 100;
				camera.position.z = 0;

				scene = new THREE.Scene();

				// Grid

				var size = 500, step = 50;

				var geometry = new THREE.Geometry();

				// for ( var i = - size; i <= size; i += step ) {

				// 	geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
				// 	geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

				// 	geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
				// 	geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

				// }

				// var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } );

				// var line = new THREE.LineSegments( geometry, material );
				// scene.add( line );

				// Cubes
				var geometry = new THREE.BoxGeometry( BOX_SIZE, BOX_SIZE, BOX_SIZE );
				var material = new THREE.MeshBasicMaterial( { color: 0x330033, shading: THREE.FlatShading, overdraw: 0.5 } );



				for ( var i = 0; i < RECTS; i ++ ) {
					var cube = new THREE.Mesh( geometry, material );

					cube.position.x = Math.random() * DISTANCE - DISTANCE / 2;
					cube.position.z = Math.random() * DISTANCE - DISTANCE / 2;

					scene.add( cube );
				}


				renderer = new THREE.CanvasRenderer();
				renderer.setClearColor( 0xf0f0f0 );
				// renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( WIDTH, HEIGHT );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.left = WIDTH / - 2;
				camera.right = WIDTH / 2;
				camera.top = HEIGHT / 2;
				camera.bottom = HEIGHT / - 2;

				camera.updateProjectionMatrix();

				renderer.setSize( WIDTH, HEIGHT );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				for ( var i = 0; i < RECTS; i ++ ) {
					var cube = scene.children[i];

					cube.position.x = Math.random() * DISTANCE - DISTANCE / 2;
					cube.position.z = Math.random() * DISTANCE - DISTANCE / 2;
				}

				camera.lookAt( scene.position );

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
