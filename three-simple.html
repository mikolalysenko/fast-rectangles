
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - camera - orthographic</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="/gits/three.js/build/three.min.js"></script>

		<script src="/gits/three.js/examples/js/renderers/Projector.js"></script>
		<script src="/gits/three.js/examples/js/renderers/CanvasRenderer.js"></script>

		<script src="/gits/three.js/examples/js/libs/stats.min.js"></script>

		<script>
			var camera, scene, renderer;

			var WIDTH = 1024;
			var HEIGHT = 768;

			var RECTS = 1000;

			init();
			animate();

			function init() {

				// camera = new THREE.OrthographicCamera( WIDTH / - 2, WIDTH / 2, HEIGHT / 2, HEIGHT / - 2, - 500, 1000 );

				camera = new THREE.OrthographicCamera( WIDTH / - 2, WIDTH / 2, HEIGHT / 2, HEIGHT / - 2, - 500, 1000 );
				camera.position.x = 0;
				// camera.position.y = 100;
				camera.position.z = 100;

				scene = new THREE.Scene();

				// Grid

				var size = 500, step = 50;

				var geometry = new THREE.Geometry();

				// for ( var i = - size; i <= size; i += step ) {

				// 	geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
				// 	geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

				// 	geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
				// 	geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

				// }

				var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2 } );

				// var line = new THREE.LineSegments( geometry, material );
				// scene.add( line );


				var material = new THREE.MeshBasicMaterial( { color: 0x330033, shading: THREE.FlatShading, overdraw: 0.5 } );


				var geometry = new THREE.PlaneGeometry(1, 1, 1, 1);

				function RectangleMesh() {
					var color = new THREE.Color(1, 1, 1);
					material = new THREE.MeshBasicMaterial({
						color: color,
						side: THREE.DoubleSide,
						wireframe: true
					})

					THREE.Mesh.call(this, geometry, material);
				}

				RectangleMesh.prototype = Object.create(THREE.Mesh.prototype);

				RectangleMesh.prototype.setRect = function(x, y, w, h) {
					this.position.x = x + w * .5;
					this.position.y = y + h * .5;
					this.scale.x = w;
					this.scale.y = h;
				}

				for ( var i = 0; i < RECTS; i ++ ) {
					// var cube = new THREE.Mesh( geometry, material );
					// cube.position.x = Math.random() * WIDTH - WIDTH / 2;
					// cube.position.z = Math.random() * HEIGHT - HEIGHT / 2;
					// scene.add( cube );


					var rect = new RectangleMesh( material );
					scene.add( rect );
				}


				// renderer = new THREE.CanvasRenderer();
				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xf0f0f0 );
				// renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( WIDTH, HEIGHT );
				document.body.appendChild( renderer.domElement );

				//

				// window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.left = WIDTH / - 2;
				camera.right = WIDTH / 2;
				camera.top = HEIGHT / 2;
				camera.bottom = HEIGHT / - 2;

				camera.updateProjectionMatrix();

				renderer.setSize( WIDTH, HEIGHT );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				for ( var i = 0; i < RECTS; i ++ ) {
					var rect = scene.children[i];

					var x, y, w, h;
					x = Math.random() * WIDTH - WIDTH / 2;
					y = Math.random() * HEIGHT - HEIGHT / 2;
					w = Math.random() * WIDTH / 4;
					h = Math.random() * HEIGHT / 4;

					// rect.position.z = x;
					// rect.position.x = y;
					// rect.scale.z = w;
					// rect.scale.x = h;

					rect.setRect(x, y, w, h);



				}

				camera.lookAt( scene.position );

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
